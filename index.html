<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js effects</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			#error {
				margin: auto;
				margin-top: 40px;
				display: block;
				max-width: 400px;
				padding: 20px;
				background: #CE0808;
			}
		</style>

		

	</head>
	<body>
		<canvas></canvas>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">threejs</a> effects<br/>
			Created by <a href="http://github.com/wizgrav" target="_blank" rel="noopener">wizgrav</a>.

			<div id="error" style="display: none;">
			Your browser does not support <strong>WEBGL_depth_texture</strong>.<br/><br/>
			This demo will not work.
			</div>
		</div>
        <script src="./dist/three-effects.js"></script>
        <script src="./node_modules/three/examples/js/controls/OrbitControls.js"></script>
        
		<script type="module">

		    var camera, scene, renderer, controls, fx;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { canvas: document.querySelector( 'canvas' ) } );

				if ( ! renderer.extensions.get( 'WEBGL_depth_texture' ) ) {

					supportsExtension = false;
					document.querySelector( '#error' ).style.display = 'block';
					return;

				}

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				//

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 50 );
				camera.position.z = 4;

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;

				
				// Our scene
				scene = new THREE.Scene();
				setupScene();

				onWindowResize();
				window.addEventListener( 'resize', onWindowResize, false );

				setupEffects();
				
			}

			function setupEffects() {
				
				fx = attachEffects(scene);

                scene.userData.time = { value: 0 };
                
				// Shader for the final compositing
                fx(`
                    uniform float time;
					
                    void main(void) {
						vec4 col = texture2D(colorTexture, vUv);
                        vec4 dep = texture2D(depthTexture, vUv);
                        float d = smoothstep(0.9, 1., dep.r);
                    	gl_FragColor.rgb = mix(col.rgb, vec3(0.), abs(sin(time * d * 2.)));
                        gl_FragColor.a = 1.0;
                    }
                `);
			}

			function setupScene() {

				//var diffuse = new TextureLoader().load( 'textures/brick_diffuse.jpg' );
				//diffuse.wrapS = diffuse.wrapT = RepeatWrapping;

				// Setup some geometries
				var geometry = new THREE.TorusKnotBufferGeometry( 1, 0.3, 128, 64 );
				var material = new THREE.MeshBasicMaterial( { color: 'blue' } );

				var count = 50;
				var scale = 5;

                var colors = [
                    new THREE.Color(0x993300),
                    new THREE.Color(0x993399),
                    new THREE.Color(0x003399),
                    new THREE.Color(0x333399),
                    new THREE.Color(0x993366)
                ];
				for ( var i = 0; i < count; i ++ ) {

					var r = Math.random() * 2.0 * Math.PI;
					var z = ( Math.random() * 2.0 ) - 1.0;
					var zScale = Math.sqrt( 1.0 - z * z ) * scale;

                    var mtl = material.clone();

                    mtl.color = colors[i % 5];

                    var mesh = new THREE.Mesh( geometry, mtl );
                    
					mesh.position.set(
						Math.cos( r ) * zScale,
						Math.sin( r ) * zScale,
						z * scale
					);
					mesh.rotation.set( Math.random(), Math.random(), Math.random() );
					scene.add( mesh );

				}

			}

			function onWindowResize() {

				var aspect = window.innerWidth / window.innerHeight;
				camera.aspect = aspect;
				camera.updateProjectionMatrix();

				var dpr = renderer.getPixelRatio();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				
				requestAnimationFrame( animate );

                scene.userData.time.value = window.performance.now() / 1000;
                
                renderer.render( scene, camera );

				controls.update(); // required because damping is enabled

			}

		</script>

	</body>
</html>